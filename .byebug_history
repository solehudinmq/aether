exit
@posts[-6]
@posts[-5]
data[4]
data[0]
exit
first_call_posts[:next_cursor][:direction]
first_call_posts[:next_cursor][:cursor_id]
data.count
data.length
data = posts[:data]
posts = Post.cursor_paginate(cursor_timestamp: first_call_posts[:next_cursor][:cursor_timestamp], cursor_id: first_call_posts[:next_cursor][:cursor_id], direction: first_call_posts[:next_cursor][:direction], limit: 5, order_by: 'asc')
first_call_posts[:next_cursor]
first_call_posts[:data].count
first_call_posts
exit
abc[:data].count
abc[:data]
abc = { data: result, next_cursor: next_cursor, previous_cursor: previous_cursor }
next_cursor = nil
      previous_cursor = nil
result.count
result = data.limit(limit)
limit
cursor_timestamp.present? && cursor_id.present? && direction.present?
data.count
data = order(cursor_timestamp: order_by, id: order_by)
order_by_validator = OrderByValidator.validate(order_by)
order_by
limit
exit
Post.count
Post.cursor_paginate(cursor_timestamp: nil, cursor_id: nil, direction: nil, limit: 5, order_by: 'desc').count
Post.cursor_paginate(cursor_timestamp: nil, cursor_id: nil, direction: nil, limit: 10, order_by: 'desc').count
Post.cursor_paginate(cursor_timestamp: nil, cursor_id: nil, direction: nil, limit: 5, order_by: 'desc').count
Post.count
first_call_posts.count
first_call_posts = Post.cursor_paginate(cursor_timestamp: nil, cursor_id: nil, direction: nil, limit: 5, order_by: 'asc')
first_call_posts.count
first_call_posts
c
first_call_posts.count
first_call_posts
@posts.first
@posts.last
@posts.count
@posts
data.count
data
c
posts[:next_cursor][:cursor_timestamp]
posts[:next_cursor]
posts
data = posts[:data]
posts[:data].length
posts[:data]
posts.data
posts
c
Post.all
c
Post.all.to_a
Post.all
